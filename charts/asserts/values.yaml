# TODO: figure out default resources for everything...
nameOverride: ""
fullnameOverride: ""
clusterDomain: svc.cluster.local

rbac:
  create: true
  annotations: {}
  extraLabels: {}

serviceAccount:
  create: true
  ## The name of the service account to use.
  ## If not set and create is true, a name is generated using the fullname template
  name:
  # Secrets for the service account
  # TODO: change this once we have public repos for everything
  # imagePullSecrets:
  #   - name: asserts-docker
  # imagePullSecrets: []
  # service account annotations
  annotations: {}
  extraLabels: {}

# TODO: link to docs
# asserts_env label (recommended)
# env: (dev|stage|prod|qe)
env:
# asserts_site label (optional)
# site: us-west-2
site:
# information about prometheus url to query
#
prometheus:
  url: prometheus-server.default.svc.cluster.local:9090
  scheme: http

### asserts-server ###
server:
  nameOverride: ""
  fullnameOverride: ""

  image:
    repository: asserts-server
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: k8s-beta

  initContainers:
    - name: wait-for-postgres
      image: asserts/wait-for:v2.2.3
      imagePullPolicy: IfNotPresent
      args:
        - "asserts-postgres.{{.Release.Namespace}}.{{.Values.clusterDomain}}:5432"
        - "-t"
        - "120"

  imagePullSecrets: []

  updateStrategy:
    type: RollingUpdate
    rollingUpdate: {}

  service:
    type: ClusterIP
    port: 8030

  ingress:
    enabled: false

    # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
    # ingressClassName: nginx

    annotations: {}

    extraLabels: {}

    hosts: []
    #   - asserts-server.domain.com

    path: /

    # pathType is only for k8s >= 1.18
    pathType: Prefix

    ## Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
    extraPaths: []
    # - path: /*
    #   backend:
    #     serviceName: ssl-redirect
    #     servicePort: use-annotation

    tls: []
    #   - secretName: asserts-server-tls
    #     hosts:
    #       - asserts-server.domain.com

  podDisruptionBudget:
    enabled: false
    # minAvailable: 1
    # maxUnavailable: 1

  resources: {}

  ## wait 30 seconds before pod termination
  ## to allow application shut down
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle
  #
  terminationGracePeriodSeconds: 30

  # common annotations for all resources without their own annotations field
  annotations: {}

  # environment variables to add to the asserts-server pod
  extraEnv:
    - name: SPRING_LIQUIDBASE_CHANGELOG
      value: "classpath:/db/changelog/db.changelog-k8s.yaml"
  # environment variables from secrets or configmaps to add to the asserts-server pod
  extraEnvFrom: []
  #   - secretRef:
  #       name: license

  annotations: {}

  extraLabels: {}

  extraPodLabels: {}

  extraPodAnnotations: {}

  nodeSelector: {}

  tolerations: []

  affinity: {}

  extraContainers: []

  extraVolumeMounts: []

  extraVolumes: []

  persistence:
    enabled: true

    ## Persistent Volume storage class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner
    #
    storageClass: ""

    # Persistent Volume access modes
    accessModes:
      - ReadWriteOnce

    # Persistent Volume size
    size: 8Gi

    # When set, will use the existing PVC for persistence
    existingClaim: ""

### asserts-ui ###
ui:
  nameOverride: ""
  fullnameOverride: ""

  image:
    repository: asserts/asserts-ui
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: k8s-beta

  imagePullSecrets: []

  service:
    type: ClusterIP
    port: 8080

  podDisruptionBudget:
    enabled: false
    # minAvailable: 1
    # maxUnavailable: 1

  resources: {}

  annotations: {}

  # environment variables to add to the asserts-ui pod
  extraEnv: []
  # environment variables from secrets or configmaps to add to the asserts-ui pod
  extraEnvFrom: []
  #   - secretRef:
  #       name: license

  extraLabels: {}

  extraPodLabels: {}

  podAnnotations: {}

  nodeSelector: {}

  tolerations: []

  affinity: {}

  extraContainers: []

  extraVolumeMounts: []

  extraVolumes: []

### grafana ###
grafana:
  nameOverride: ""
  fullnameOverride: ""

  image:
    repository: asserts/grafana
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: k8s-beta

  imagePullSecrets: []

  updateStrategy:
    type: RollingUpdate
    rollingUpdate: {}

  service:
    type: ClusterIP
    port: 3000

  resources: {}

  persistence:
    enabled: false

    ## Persistent Volume storage class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner
    #
    storageClass: ""

    # Persistent Volume access modes
    accessModes:
      - ReadWriteOnce

    # Persistent Volume size
    size: 8Gi

    # When set, will use the existing PVC for persistence
    existingClaim: ""

### knowledge-sensor ###
#
knowledge-sensor:
  image:
    repository: asserts/knowledge-sensor
    tag: k8s-beta

  serviceAccount:
    create: false
    name: asserts

  initContainers:
    - name: wait-for-rules-api
      image: asserts/wait-for:v2.2.3
      imagePullPolicy: IfNotPresent
      args:
        - "{{.Release.Name}}-server.{{.Release.Namespace}}.{{.Values.clusterDomain}}:8030"
        - "-t"
        - "180"

  assertsTenant: bootstrap
  assertsControllerHost: "http://{{.Release.Name}}-server.{{.Release.Namespace}}.{{.Values.clusterDomain}}:8030"
  syncInterval: "60"
  prometheusRulesConfigmapName: "asserts-rules"
  prometheusRulesTargetDir: "/etc/asserts/rules"
  prometheusRelabelRulesConfigmapName: "asserts-relabel-rules"
  prometheusRelabelRulesTargetDir: /etc/asserts/relabel

  concurrency:
    enabled: false

### tsdb ###
# ref: https://github.com/VictoriaMetrics/helm-charts/blob/master/charts/victoria-metrics-single/values.yaml
tsdb:
  enabled: true
  rbac:
    create: false
    pspEnabled: false

  serviceAccount:
    create: false
    name: asserts

  configMap: asserts-tsdb-scrapeconfig
  server:
    image:
      tag: v1.75.1

    nameOverride: "tsdb"
    fullNameOverride: "tsdb"

    initContainers:
      - name: wait-for-knowledge-sensor
        image: asserts/wait-for:v2.2.3
        imagePullPolicy: IfNotPresent
        args:
          - "{{.Release.Name}}-knowledge-sensor.{{.Release.Namespace}}.{{.Values.clusterDomain}}:8080"
          - "-t"
          - "180"
      - name: init-add-rule-files
        # TODO: make custom sidecar public in dockerhub
        image: asserts-k8s-sidecar:k8s
        imagePullPolicy: IfNotPresent
        env:
          - name: LABEL
            value: bootstrap-relabel-config
          - name: FOLDER
            value: /etc/asserts/relabel
          - name: METHOD
            value: LIST
        volumeMounts:
          - name: relabel-config
            mountPath: /etc/asserts/relabel

    extraArgs:
      loggerFormat: default
      # TODO: look in to generalizing relabel config for single/multi-tenancy
      relabelConfig: /etc/asserts/relabel/bootstrap.yml
      maxLabelsPerTimeseries: 60
      retentionPeriod: 14d
      search.maxStalenessInterval: 60s
      search.latencyOffset: 15s
      memory.allowedPercent: 50

    # scrape configuration for the tsdb in templates/tsdb-scrape-configmap.yaml
    scrape:
      enabled: true
      configMap: asserts-tsdb-scrapeconfig

    persistentVolume:
      size: 8Gi

    # TODO: figure out good default resources
    resources: {}

    # TODO: decide if we want these set, can be problematic for statefulsets
    readinessProbe:
    livenessProbe:

    extraContainers:
      # TODO: reload scrape config if changed
      - name: config-sidecar
        # TODO: make custom sidecar public in dockerhub
        image: asserts-k8s-sidecar:k8s
        imagePullPolicy: IfNotPresent
        resources: {}
        env:
          # TODO: different tenant name?
          - name: LABEL
            value: bootstrap-relabel-config
          - name: FOLDER
            value: /etc/asserts/relabel
          - name: REQ_URL
            value: http://localhost:8428/-/reload
        volumeMounts:
          - name: relabel-config
            mountPath: /etc/asserts/relabel

    extraVolumeMounts:
      - name: relabel-config
        mountPath: /etc/asserts/relabel

    extraVolumes:
      - name: relabel-config
        emptyDir: {}


### redisgraph ###
# ref: https://github.com/bitnami/charts/blob/master/bitnami/redis/values.yaml
redisgraph:
  enabled: true

  image:
    repository: asserts/redismod
    tag: 6.26

  nameOverride: asserts-redisgraph
  fullnameOverride: asserts-redisgraph

  serviceAccount:
    create: false
    name: asserts

  architecture: standalone

  auth:
    enabled: false

  master:
    configuration: |
      loadmodule /opt/bitnami/redis/modules/redisgraph.so

  metrics:
    enabled: true


### redisearch ###
# ref: https://github.com/bitnami/charts/blob/master/bitnami/redis/values.yaml
redisearch:
  enabled: true

  image:
    repository: asserts/redismod
    tag: 6.26

  nameOverride: asserts-redisearch
  fullnameOverride: asserts-redisearch

  serviceAccount:
    create: false
    name: asserts

  architecture: standalone

  auth:
    enabled: false

  master:
    configuration: |
      loadmodule /opt/bitnami/redis/modules/redisearch.so

  metrics:
    enabled: true


### alertmanager ###
# ref: https://github.com/prometheus-community/helm-charts/blob/main/charts/alertmanager/values.yaml
alertmanager:
  enabled: true

  serviceAccountName: asserts
  serviceAccount:
    create: false
    name: asserts

  persistence:
    enabled: true
    accessModes:
      - ReadWriteOnce
    size: 100Mi

  existingConfigMap: asserts-alertmanager

  configmapReload:
    enabled: true

### promxy ###
# ref: https://github.com/asserts/helm-charts/blob/master/charts/promxy/values.yaml
promxy:
  enabled: true
  serviceAccount:
    create: false
    name: asserts

  existingConfigMap: asserts-promxy

  extraContainers:
    - name: config-sidecar
      # TODO: make custom sidecar public in dockerhub
      image: asserts-k8s-sidecar:k8s
      imagePullPolicy: IfNotPresent
      resources: {}
      env:
        # TODO: different tenant name?
        - name: LABEL
          value: bootstrap-rules-config
        - name: FOLDER
          value: /etc/asserts/rules
        - name: REQ_URL
          value: http://localhost:8082/-/reload
        - name: REQ_METHOD
          value: POST
      volumeMounts:
        - name: rules-config
          mountPath: /etc/asserts/rules

  extraVolumeMounts:
    - name: rules-config
      mountPath: /etc/asserts/rules

  # TODO: figure out race condition where vm reads the relabel config before sidecar
  #       adds it. Possible options:
  #
  #       1. touch a file: hacky and could trigger reload of no rules
  #       2. use configmap reloader
  #       3. reorder container startup and add post start sleep of 15 seconds
  #       4. leave as is and allow pod to crash twice
  extraVolumes:
    - name: rules-config
      emptyDir: {}


### postgres ###
# ref: https://github.com/bitnami/charts/blob/master/bitnami/postgresql/values.yaml
postgres:
  enabled: true

  defaultPassword: super-secret

  global:
    postgresql:
      auth:
        database: "asserts"
        existingSecret: "asserts-default"

  image:
    repository: bitnami/postgresql
    tag: 12.7.0

  nameOverride: asserts-postgres
  fullnameOverride: asserts-postgres

  serviceAccount:
    create: false
    name: asserts

  primary:
    initdb:
      scripts:
        load-extensions.sh: |
          #!/bin/sh

          psql --username "postgres" <<EOF
          create extension IF NOT EXISTS pg_stat_statements;
          select * FROM pg_extension;
          EOF

  metrics:
    enabled: true
    customMetrics: |
      pg_replication:
        query: "SELECT EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())) as lag"
        master: true
        metrics:
          - lag:
              usage: "GAUGE"
              description: "Replication lag behind master in seconds"

      pg_postmaster:
        query: "SELECT pg_postmaster_start_time as start_time_seconds from pg_postmaster_start_time()"
        master: true
        metrics:
          - start_time_seconds:
              usage: "GAUGE"
              description: "Time at which postmaster started"

      pg_stat_user_tables:
        query: "SELECT current_database() datname, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, COALESCE(last_vacuum, '1970-01-01Z'), COALESCE(last_vacuum, '1970-01-01Z') as last_vacuum, COALESCE(last_autovacuum, '1970-01-01Z') as last_autovacuum, COALESCE(last_analyze, '1970-01-01Z') as last_analyze, COALESCE(last_autoanalyze, '1970-01-01Z') as last_autoanalyze, vacuum_count, autovacuum_count, analyze_count, autoanalyze_count FROM pg_stat_user_tables"
        metrics:
          - datname:
              usage: "LABEL"
              description: "Name of current database"
          - schemaname:
              usage: "LABEL"
              description: "Name of the schema that this table is in"
          - relname:
              usage: "LABEL"
              description: "Name of this table"
          - seq_scan:
              usage: "COUNTER"
              description: "Number of sequential scans initiated on this table"
          - seq_tup_read:
              usage: "COUNTER"
              description: "Number of live rows fetched by sequential scans"
          - idx_scan:
              usage: "COUNTER"
              description: "Number of index scans initiated on this table"
          - idx_tup_fetch:
              usage: "COUNTER"
              description: "Number of live rows fetched by index scans"
          - n_tup_ins:
              usage: "COUNTER"
              description: "Number of rows inserted"
          - n_tup_upd:
              usage: "COUNTER"
              description: "Number of rows updated"
          - n_tup_del:
              usage: "COUNTER"
              description: "Number of rows deleted"
          - n_tup_hot_upd:
              usage: "COUNTER"
              description: "Number of rows HOT updated (i.e., with no separate index update required)"
          - n_live_tup:
              usage: "GAUGE"
              description: "Estimated number of live rows"
          - n_dead_tup:
              usage: "GAUGE"
              description: "Estimated number of dead rows"
          - n_mod_since_analyze:
              usage: "GAUGE"
              description: "Estimated number of rows changed since last analyze"
          - last_vacuum:
              usage: "GAUGE"
              description: "Last time at which this table was manually vacuumed (not counting VACUUM FULL)"
          - last_autovacuum:
              usage: "GAUGE"
              description: "Last time at which this table was vacuumed by the autovacuum daemon"
          - last_analyze:
              usage: "GAUGE"
              description: "Last time at which this table was manually analyzed"
          - last_autoanalyze:
              usage: "GAUGE"
              description: "Last time at which this table was analyzed by the autovacuum daemon"
          - vacuum_count:
              usage: "COUNTER"
              description: "Number of times this table has been manually vacuumed (not counting VACUUM FULL)"
          - autovacuum_count:
              usage: "COUNTER"
              description: "Number of times this table has been vacuumed by the autovacuum daemon"
          - analyze_count:
              usage: "COUNTER"
              description: "Number of times this table has been manually analyzed"
          - autoanalyze_count:
              usage: "COUNTER"
              description: "Number of times this table has been analyzed by the autovacuum daemon"

      pg_statio_user_tables:
        query: "SELECT current_database() datname, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read, tidx_blks_hit FROM pg_statio_user_tables"
        metrics:
          - datname:
              usage: "LABEL"
              description: "Name of current database"
          - schemaname:
              usage: "LABEL"
              description: "Name of the schema that this table is in"
          - relname:
              usage: "LABEL"
              description: "Name of this table"
          - heap_blks_read:
              usage: "COUNTER"
              description: "Number of disk blocks read from this table"
          - heap_blks_hit:
              usage: "COUNTER"
              description: "Number of buffer hits in this table"
          - idx_blks_read:
              usage: "COUNTER"
              description: "Number of disk blocks read from all indexes on this table"
          - idx_blks_hit:
              usage: "COUNTER"
              description: "Number of buffer hits in all indexes on this table"
          - toast_blks_read:
              usage: "COUNTER"
              description: "Number of disk blocks read from this table's TOAST table (if any)"
          - toast_blks_hit:
              usage: "COUNTER"
              description: "Number of buffer hits in this table's TOAST table (if any)"
          - tidx_blks_read:
              usage: "COUNTER"
              description: "Number of disk blocks read from this table's TOAST table indexes (if any)"
          - tidx_blks_hit:
              usage: "COUNTER"
              description: "Number of buffer hits in this table's TOAST table indexes (if any)"

      pg_database:
        query: "SELECT pg_database.datname, pg_database_size(pg_database.datname) as size FROM pg_database"
        master: true
        cache_seconds: 30
        metrics:
          - datname:
              usage: "LABEL"
              description: "Name of the database"
          - size_bytes:
              usage: "GAUGE"
              description: "Disk space used by the database"

      pg_stat_statements:
        query: "SELECT t2.rolname, t3.datname, queryid, calls, total_time / 1000 as total_time_seconds, min_time / 1000 as min_time_seconds, max_time / 1000 as max_time_seconds, mean_time / 1000 as mean_time_seconds, stddev_time / 1000 as stddev_time_seconds, rows, shared_blks_hit, shared_blks_read, shared_blks_dirtied, shared_blks_written, local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written, temp_blks_read, temp_blks_written, blk_read_time / 1000 as blk_read_time_seconds, blk_write_time / 1000 as blk_write_time_seconds FROM pg_stat_statements t1 join pg_roles t2 on (t1.userid=t2.oid) join pg_database t3 on (t1.dbid=t3.oid)"
        master: true
        metrics:
          - rolname:
              usage: "LABEL"
              description: "Name of user"
          - datname:
              usage: "LABEL"
              description: "Name of database"
          - queryid:
              usage: "LABEL"
              description: "Query ID"
          - calls:
              usage: "COUNTER"
              description: "Number of times executed"
          - total_time_seconds:
              usage: "COUNTER"
              description: "Total time spent in the statement, in milliseconds"
          - min_time_seconds:
              usage: "GAUGE"
              description: "Minimum time spent in the statement, in milliseconds"
          - max_time_seconds:
              usage: "GAUGE"
              description: "Maximum time spent in the statement, in milliseconds"
          - mean_time_seconds:
              usage: "GAUGE"
              description: "Mean time spent in the statement, in milliseconds"
          - stddev_time_seconds:
              usage: "GAUGE"
              description: "Population standard deviation of time spent in the statement, in milliseconds"
          - rows:
              usage: "COUNTER"
              description: "Total number of rows retrieved or affected by the statement"
          - shared_blks_hit:
              usage: "COUNTER"
              description: "Total number of shared block cache hits by the statement"
          - shared_blks_read:
              usage: "COUNTER"
              description: "Total number of shared blocks read by the statement"
          - shared_blks_dirtied:
              usage: "COUNTER"
              description: "Total number of shared blocks dirtied by the statement"
          - shared_blks_written:
              usage: "COUNTER"
              description: "Total number of shared blocks written by the statement"
          - local_blks_hit:
              usage: "COUNTER"
              description: "Total number of local block cache hits by the statement"
          - local_blks_read:
              usage: "COUNTER"
              description: "Total number of local blocks read by the statement"
          - local_blks_dirtied:
              usage: "COUNTER"
              description: "Total number of local blocks dirtied by the statement"
          - local_blks_written:
              usage: "COUNTER"
              description: "Total number of local blocks written by the statement"
          - temp_blks_read:
              usage: "COUNTER"
              description: "Total number of temp blocks read by the statement"
          - temp_blks_written:
              usage: "COUNTER"
              description: "Total number of temp blocks written by the statement"
          - blk_read_time_seconds:
              usage: "COUNTER"
              description: "Total time the statement spent reading blocks, in milliseconds (if track_io_timing is enabled, otherwise zero)"
          - blk_write_time_seconds:
              usage: "COUNTER"
              description: "Total time the statement spent writing blocks, in milliseconds (if track_io_timing is enabled, otherwise zero)"
